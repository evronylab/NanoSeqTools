#' Load NanoSeq data for genome-wide analysis
#'
#' This function loads NanoSeq data required for genome-wide analysis. For more information regarding NanoSeq output files, refer to the "output" section in the [NanoSeq GitHub](https://github.com/cancerit/NanoSeq).
#'
#' @param dirs A character vector of the directories containing NanoSeq results to load (one directory per sample).
#' @param sample_names A character vector of the sample names to assign to the results, in the same order as the directories in 'dirs'.
#' @param BSgenomepackagename A string of a BSgenome package corresponding to the reference genome used in the Nanoseq analysis (e.g., "BSgenome.Hsapiens.UCSC.hg38" or "BSgenome.Mmusculus.UCSC.mm10"). This is used to calculate the genome trinucleotide background and corrected substitution counts and burdens.
#' @param genome_contigs A character vector of reference genome contig names from which to calculate the genome trinucleotide background. This should match the contigs analyzed by the main NanoSeq pipeline.
#' @param exclude_regions A GRanges (strand is ignored) object with additional regions to filter from substitution and indel mutations. This also subtracts those regions from the number of interrogated bases using the sample's bed coverage information. Note: deletions that only partially span an excluded region are not filtered, and insertions are excluded based on the POS column's single base coordinate in the VCF. Default is no regions (i.e. NULL).
#' @param bedtools_bin Full path of bedtools binary
#' @return A list of data files with all the relevant results generated by NanoSeq.
#' * sample_names: A vector of all sample IDs that were loaded
#' * dirs: A character vector of the directories containing the NanoSeq results that were loaded
#' * BSgenomepackagename: BSgenome package name used for the analysis
#' * genome_contigs: reference genome contig names used for the analysis
#' * exclude_regions: GRanges object of the input parameter of additional regions to filter
#' * vcf_snp.fix: List (one object per sample) containing the fixed information (fix) from the SNP vcf (only FILTER = PASS mutations)
#' * vcf_indel.fix: List (one object per sample) containing the fixed information (fix) from the indel vcf (only FILTER = PASS mutations)
#' * vcf_indel.gt: List (one object per sample) containing the genotype information (gt) from the indel vcf (only FILTER = PASS mutations)
#' * indel_counts.sigfit: Data frame in sigfit format of unique observed indel counts (created with indelwald indel.spectrum function), with one row per sample and one column per indel context
#' * trinuc_bg_counts_ratio: Data frame of the sample trinucleotide background counts (i.e. number of interrogated bases for each trinucleotide context), the genome trinucleotide background counts (i.e. number of each trinucleotide context), and the normalized ratio of these. Columns: sample, tri (trinucleotide context), sample_tri_bg, genome_tri_bg, ratio2genome.
#' * trinuc_bg_counts.sigfit: Data frame in sigfit format of the sample trinucleotide background counts, with one row per sample and one column per trinucleotide context.
#' * trinuc_bg_ratio.sigfit: Data frame in sigfit format of the ratio of the sample trinucleotide background counts (normalized to a sum of 1) to the genome trinucleotide background counts (normalized to a sum of 1), with one row per sample and one column per trinucleotide context.
#' * genome_trinuc_counts.sigfit: Vector of the genome trinucleotide background counts, in the same order as columns in sigfit format columns.
#' * observed_corrected_trinuc_counts: Data frame of observed and corrected substitution mutation counts (for all mutations and for unique mutations). Columns: sample, tri (trinucleotide context), trint_subst_observed, trint_subst_unique_observed, ratio2genome, trint_subst_corrected, trint_subst_unique_corrected.
#' * observed_trinuc_counts.sigfit: Data frame in sigfit format of unique observed substitution mutation counts, with one row per sample and one column per trinucleotide substitution context.
#' * mutation_burden, with one row per sample. All substitution mutation statistics include all mutations, not just unique mutations. Indel statistics are calculated both for all and for unique mutations.
#'  - The number of observed and corrected substitution mutations (muts_observed and muts_corrected)
#'  - Number of all and unique observed indels (indels_observed, indels_unique_observed)
#'  - Total number of observed and corrected interrogated bases (total_observed and total_corrected; note: observed and corrected are the same)
#'  - Observed and corrected substitution mutation burdens (burden_observed and burden_corrected)
#'  - All and unique observed indel mutation burden (burden_indels_observed and burden_indels_unique_observed)
#'  - Observed and corrected lower and upper confidence intervals of substitution mutation counts and all and unique observed lower and upper confidence intervals of indel counts (muts_lci_observed, muts_lci_corrected, indels_lci_observed, indels_unique_lci_observed, muts_uci_observed, muts_uci_corrected, indels_uci_observed, indels_unique_uci_observed)
#'  - Observed and corrected lower and upper confidence intervals of substitution mutation burdens and all and unique observed lower and upper confidence intervals of indel mutation burdens (burden_lci_observed, burden_lci_corrected, burden_indels_lci_observed, burden_indels_unique_lci_observed, burden_uci_observed, burden_uci_corrected, burden_indels_uci_observed, burden_indels_unique_uci_observed)
#' * purine_trinuc_mismatches: Data frame of the number of single-strand consensus purine mismatches. Columns: sample, tri (trinucleotide context), value.
#' * pyrimidine_trinuc_mismatches: Data frame of the number of single-strand consensus pyrimidine mismatches. Columns: sample, tri (trinucleotide context), value.
#' * estimated_error_rates: Data frame of the probability of having independent errors affecting both strands and resulting in a false-positive double-strand mutation and the number of estimated false positive double-strand mutations, based on the independent error rates in the purine channels. Columns: sample, total_error_rate, total_errors.
#' @export

load_nanoseq_data <- function(dirs, sample_names, BSgenomepackagename, genome_contigs, exclude_regions = NULL, bedtools_bin) {
  
  # Load packages required only by this function
  suppressPackageStartupMessages(library(BSgenomepackagename,character.only=TRUE))
  suppressPackageStartupMessages(library(vcfR))
  
  # Check inputs
  if(length(dirs) != length(sample_names)){
    stop("Length of dirs does not equal length of sample_names!")
  }
  
   # Make genome chrom info file (required for bedtools), and export exclude_regions to BED file after assigning reference genome seqlevels and removing strand information (if present). Note, reduce function sorts by seqlevels, so there is no need to separately sort prior to export.
  if(!is.null(exclude_regions)){
  	tmp.genomechrominfo <- tempfile()
  	bind_cols(
  		seqnames=seqnames(eval(parse(text=BSgenomepackagename))),
  		seqlengths=seqlengths(eval(parse(text=BSgenomepackagename)))
  	) %>%
  		write_tsv(tmp.genomechrominfo,col_names=FALSE)
  	
    seqlevels(exclude_regions) <- seqlevels(eval(parse(text=BSgenomepackagename)))
  	strand(exclude_regions) <- "*"
  	tmp.exclude_regions <- tempfile(fileext=".bed")
  	exclude_regions %>% GenomicRanges::reduce(ignore.strand=TRUE) %>% export(con=tmp.exclude_regions,format="bed")
  }
  
  # Initialize lists for results
  vcf_snp.fix <- list()
  vcf_indel.fix <- list()
  vcf_indel.gt <- list()
  indel_counts <- list()
  results.trint_counts_and_ratio2genome <- list()
  results.trint_subs_obs_corrected <- list()
  results.mut_burden <- list()
  results.SSC_mismatches_purine <- list()
  results.SSC_mismatches_pyrimidine <- list()
  results.estimated_error_rates <- list()
  
  #Calculate reference genome trinucleotide counts, reduced to 32 trinucleotide contexts
  message("Loading reference genome data...")
  genome_trinuc_counts <- NULL
  for(i in genome_contigs){
    genome_trinuc_counts <- rbind(genome_trinuc_counts,trinucleotideFrequency(eval(parse(text=BSgenomepackagename))[[i]]))
  }
  genome_trinuc_counts <- genome_trinuc_counts %>% colSums %>% trinucleotide64to32 %>% as.data.frame %>% rownames_to_column("tri")
  colnames(genome_trinuc_counts)[2] <- "genome_tri_bg"
  
  #Convert BSgenome to StringSet object for indel spectrum loading
  BSgenome.StringSet <- as(sapply(seqnames(eval(parse(text=BSgenomepackagename))),function(x){eval(parse(text=BSgenomepackagename))[[x]]}),"DNAStringSet")
  
  message("Loading sample data...")
  pb <- txtProgressBar(min=0,max=100,style=3)
  
  for(i in 1:length(dirs)){
    
    dir <- dirs[i]
    sample_name <- sample_names[i]

    setTxtProgressBar(pb,i/length(dirs)*100)

    # Load vcf files
    vcf_snp <- read.vcfR(paste0(dir,"/results.muts.vcf.gz"),verbose=FALSE)
    vcf_snp.fix[[sample_name]] <- data.frame(vcf_snp@fix) %>%	filter(FILTER == "PASS") %>% mutate(POS=as.numeric(POS))
    
    vcf_indel <- read.vcfR(paste0(dir,"/results.indel.vcf.gz"),verbose=FALSE)
    vcf_indel.fix[[sample_name]] <- data.frame(vcf_indel@fix) %>% filter(FILTER == "PASS") %>% mutate(POS=as.numeric(POS))
    vcf_indel.gt[[sample_name]] <- data.frame(vcf_indel@gt) %>% filter(data.frame(vcf_indel@fix)$FILTER == "PASS")
    
    # If exclude_regions is defined, obtain trinucleotide background for exclude_regions to subtract later from background counts, and then filter substitutions and indels within exclude_regions
    if(!is.null(exclude_regions)){
    	
    	#Load coverage information for exclude_regions
    	tmp.bedcov.exclude_regions <- tempfile()
    	cmdoutput <- system(paste(bedtools_bin,"intersect -sorted -wa -g",tmp.genomechrominfo,"-a",paste0(dir,"/results.cov.bed.gz"),"-b",tmp.exclude_regions,"| tr ';' '\t' | awk 'BEGIN{OFS=\"\t\"}{print $1,$2,$3,$6,$4,$5}' >",tmp.bedcov.exclude_regions))
    	
    	if(cmdoutput != 0){stop("Stopping: error in BEDTools command!")}
    	
    	bedcov.exclude_regions <- import(tmp.bedcov.exclude_regions,format="bedgraph")
    	seqlevels(bedcov.exclude_regions) <- seqlevels(eval(parse(text=BSgenomepackagename)))
    	invisible(file.remove(tmp.bedcov.exclude_regions))
    	
    	if(length(bedcov.exclude_regions)==0){
    		bedcov.exclude_regions <- data.frame(tri=trinucleotides_64,exclude_tri_bg=0) %>%
    			deframe %>%
    			trinucleotide64to32 %>%
    			as_tibble(rownames="tri") %>%
    			dplyr::rename(exclude_tri_bg=value)
    	}else{
    		#Calculate trinucleotide counts for exclude_regions
    		colnames(mcols(bedcov.exclude_regions)) <- c("coverage","tri","ref")
    		bedcov.exclude_regions <- mcols(bedcov.exclude_regions)[,c("tri","coverage")] %>%
    			as.data.frame %>%
    		  group_by(tri) %>%
    		  summarize(n=sum(coverage)) %>%
    			left_join(data.frame(tri=trinucleotides_64),.,by="tri") %>%
    			replace(is.na(.),0) %>%
    			deframe %>%
    			trinucleotide64to32 %>%
    			as_tibble(rownames="tri") %>%
    			dplyr::rename(exclude_tri_bg=value)
    	}
    	
    	#Make temporary GRanges versions of vcf_snp.fix and vcf_indel.fix for filtering exclude_regions.
    	vcf_snp.fix.gr <- vcf_snp.fix[[sample_name]] %>% makeGRangesFromDataFrame(seqnames.field="CHROM",start.field="POS",end.field="POS")
    	seqlevels(vcf_snp.fix.gr) <- seqlevels(eval(parse(text=BSgenomepackagename)))
    	
    	vcf_indel.fix.gr <- vcf_indel.fix[[sample_name]] %>% vcf_indel_toGRanges
    	seqlevels(vcf_indel.fix.gr) <- seqlevels(eval(parse(text=BSgenomepackagename)))
    	
    	#Filter snps and indels within exclude_regions
    	vcf_snp.fix[[sample_name]] <- vcf_snp.fix[[sample_name]] %>% filter(countOverlaps(vcf_snp.fix.gr,exclude_regions) == 0)
    	vcf_indel.fix[[sample_name]] <- vcf_indel.fix[[sample_name]] %>% filter(countOverlaps(vcf_indel.fix.gr,exclude_regions,type="within") == 0)
    	vcf_indel.gt[[sample_name]] <- vcf_indel.gt[[sample_name]] %>% filter(countOverlaps(vcf_indel.fix.gr,exclude_regions,type="within") == 0)
    }
    
    # Calculate number of unique indel counts for each indel context
    indel_counts[[sample_name]] <- vcf_indel.fix[[sample_name]] %>%
    	distinct(CHROM,POS,REF,ALT) %>%
    	indel.spectrum(BSgenome.StringSet) %>%
    	indelwald.to.sigfit
    
    # Load sample and genome trinucleotide background counts
    results.trint_counts_and_ratio2genome[[sample_name]] <- read.delim(paste0(dir,"/results.trint_counts_and_ratio2genome.tsv"),header=FALSE,skip=1) %>%
      dplyr::select(-V3) %>%
      dplyr::rename(tri=V1,sample_tri_bg=V2) %>%
      left_join(genome_trinuc_counts,by="tri")
    
    # Subtract trinucleotide counts of excluded regions from sample background counts
    if(!is.null(exclude_regions)){
	    results.trint_counts_and_ratio2genome[[sample_name]] <- results.trint_counts_and_ratio2genome[[sample_name]] %>%
	    	left_join(bedcov.exclude_regions,by="tri") %>%
	    	mutate(sample_tri_bg = sample_tri_bg - exclude_tri_bg) %>%
	    	dplyr::select(-exclude_tri_bg)
    }
    
    # Calculate ratio of sample and genome trinucleotide background counts
    results.trint_counts_and_ratio2genome[[sample_name]] <- results.trint_counts_and_ratio2genome[[sample_name]] %>%
    	mutate(ratio2genome=(sample_tri_bg/sum(sample_tri_bg))/(genome_tri_bg/sum(genome_tri_bg)) )
    
    #Calculate number of observed and corrected substitutions in each trinucleotide context, both for all mutations and after collapsing to unique mutations
    vcf_snp.fix.all <- vcf_snp.fix[[sample_name]] %>%
    	dplyr::select(CHROM,POS,REF,ALT,INFO) %>%
      mutate(INFO = str_replace(INFO,".*TRI=",""),
      			 INFO = str_replace(INFO,";.*",""),
      			 tri = str_c(str_sub(INFO,1,4),str_sub(INFO,1,1),str_sub(INFO,5,5),str_sub(INFO,3,3))
      ) %>%
    	dplyr::select(-INFO)
    
    vcf_snp.fix.unique <- vcf_snp.fix.all %>% distinct
    
    vcf_snp.fix.all <- vcf_snp.fix.all %>% dplyr::select(tri) %>% table %>% as.data.frame %>% dplyr::rename(trint_subst_observed = Freq)
    vcf_snp.fix.unique <- vcf_snp.fix.unique %>% dplyr::select(tri) %>% table %>% as.data.frame %>% dplyr::rename(trint_subst_unique_observed = Freq)
    
    results.trint_subs_obs_corrected[[sample_name]] <- left_join(data.frame(tri = trint_subs_labels),vcf_snp.fix.all,by="tri") %>%
    	left_join(vcf_snp.fix.unique,by="tri") %>%
    	replace(is.na(.), 0) %>%
      mutate(tri_short=str_sub(tri,1,3)) %>%
      left_join(results.trint_counts_and_ratio2genome[[sample_name]] %>% dplyr::select(tri,ratio2genome),by=c("tri_short" = "tri")) %>%
      mutate(trint_subst_corrected = trint_subst_observed / ratio2genome,
      			 trint_subst_unique_corrected = trint_subst_unique_observed / ratio2genome) %>%
      dplyr::select(-tri_short)
    
    results.mut_burden[[sample_name]] <- data.frame(
      muts_observed = sum(results.trint_subs_obs_corrected[[sample_name]]$trint_subst_observed),
      muts_corrected = sum(results.trint_subs_obs_corrected[[sample_name]]$trint_subst_corrected),
      indels_observed = vcf_indel.fix[[sample_name]] %>% nrow,
      indels_unique_observed = vcf_indel.fix[[sample_name]] %>% distinct(CHROM,POS,REF,ALT) %>% nrow,
      total_observed = sum(results.trint_counts_and_ratio2genome[[sample_name]]$sample_tri_bg),
      total_corrected = sum(results.trint_counts_and_ratio2genome[[sample_name]]$sample_tri_bg)
    ) %>%
    	mutate(
	    	burden_observed = muts_observed / total_observed,
	    	burden_corrected = muts_corrected / total_corrected,
	    	burden_indels_observed = indels_observed / total_observed,
	    	burden_indels_unique_observed = indels_unique_observed / total_observed,
	    	muts_lci_observed = poisson.test(muts_observed)$conf.int[1],
	    	muts_lci_corrected = muts_lci_observed / muts_observed * muts_corrected,
	    	indels_lci_observed = poisson.test(indels_observed)$conf.int[1],
	    	indels_unique_lci_observed = poisson.test(indels_unique_observed)$conf.int[1],
	    	muts_uci_observed = poisson.test(muts_observed)$conf.int[2],
	    	muts_uci_corrected = muts_uci_observed / muts_observed * muts_corrected,
	    	indels_uci_observed = poisson.test(indels_observed)$conf.int[2],
	    	indels_unique_uci_observed = poisson.test(indels_unique_observed)$conf.int[2],
	    	burden_lci_observed = muts_lci_observed / total_observed,
	    	burden_lci_corrected = muts_lci_corrected / total_corrected,
	    	burden_indels_lci_observed = indels_lci_observed / total_observed,
	    	burden_indels_unique_lci_observed = indels_unique_lci_observed / total_observed,
	    	burden_uci_observed = muts_uci_observed / total_observed,
	    	burden_uci_corrected = muts_uci_corrected / total_corrected,
	    	burden_indels_uci_observed = indels_uci_observed / total_observed,
	    	burden_indels_unique_uci_observed = indels_unique_uci_observed / total_observed
    	)
    
    results.SSC_mismatches_purine[[sample_name]] <- read.delim(paste0(dir,"/results.SSC-mismatches-Purine.triprofiles.tsv"), header=FALSE) %>%
      mutate(tri = str_c(str_sub(V1,1,4),str_sub(V1,1,1),str_sub(V1,5,5),str_sub(V1,3,3))) %>%
      dplyr::rename(value=V2) %>%
      dplyr::select(tri,value)
    
    results.SSC_mismatches_pyrimidine[[sample_name]] <- read.delim(paste0(dir,"/results.SSC-mismatches-Pyrimidine.triprofiles.tsv"), header=FALSE) %>%
      mutate(tri = str_c(str_sub(V1,1,4),str_sub(V1,1,1),str_sub(V1,5,5),str_sub(V1,3,3))) %>%
      dplyr::rename(value=V2) %>%
      dplyr::select(tri,value)
    
    results.estimated_error_rates[[sample_name]] <- read.delim(paste0(dir,"/results.estimated_error_rates.tsv"), header=FALSE, row.names=1) %>%
    	t %>%
    	as.data.frame %>%
    	remove_rownames
  }
  close(pb)
  
  #Delete temporary files
  if(!is.null(exclude_regions)){
  	invisible(file.remove(tmp.genomechrominfo,tmp.exclude_regions))
  }
  
  # Collapse lists to data frames
  message("Combining sample data into data frames...")
  results.trint_counts_and_ratio2genome <- bind_rows(results.trint_counts_and_ratio2genome,.id="sample")
  results.trint_subs_obs_corrected <- bind_rows(results.trint_subs_obs_corrected,.id="sample")
  results.mut_burden <- bind_rows(results.mut_burden,.id="sample")
  results.SSC_mismatches_purine <- bind_rows(results.SSC_mismatches_purine,.id="sample")
  results.SSC_mismatches_pyrimidine <- bind_rows(results.SSC_mismatches_pyrimidine,.id="sample")
  results.estimated_error_rates <- bind_rows(results.estimated_error_rates,.id="sample")
  
  #Create sigfit format data frames, with samples in rows and trinucleotide contexts in columns, for:
  # a) indel counts spectra
  # b) sample trinucleotide background counts
  # c) ratios of the sample trinucleotide background counts to the genome trinucleotide background counts
  # d) observed unique mutation counts. Note: using unique mutation counts, since that is a more faithful representation of the mutational process.
  indel_counts.sigfit <- bind_rows(indel_counts,.id="sample") %>%
    column_to_rownames("sample")
  
  results.sample_tri_bg.sigfit <- results.trint_counts_and_ratio2genome %>%
  	dplyr::select(sample,tri,sample_tri_bg) %>%
  	pivot_wider(names_from=tri,values_from=sample_tri_bg) %>%
  	column_to_rownames("sample")
  results.sample_tri_bg.sigfit <- results.sample_tri_bg.sigfit[,genome_freqs_labels] %>% set_names(genome_freqs_labels)
  
  results.ratio2genome.sigfit <- results.trint_counts_and_ratio2genome %>%
    dplyr::select(sample,tri,ratio2genome) %>%
    pivot_wider(names_from=tri,values_from=ratio2genome) %>%
    column_to_rownames("sample")
  results.ratio2genome.sigfit <- results.ratio2genome.sigfit[,genome_freqs_labels] %>% set_names(genome_freqs_labels)

  results.trint_subst_obs.sigfit <- results.trint_subs_obs_corrected %>%
    dplyr::select(sample,tri,trint_subst_unique_observed) %>%
    pivot_wider(names_from=tri,values_from=trint_subst_unique_observed) %>%
    column_to_rownames("sample")
  
  # Format genome_trinuc_counts to named vector in order of genome_freqs_labels
  genome_trinuc_counts.sigfit <- genome_trinuc_counts %>% column_to_rownames("tri")
  genome_trinuc_counts.sigfit <- genome_trinuc_counts.sigfit[genome_freqs_labels,] %>% set_names(genome_freqs_labels)
  
  # Create a list or data structure to store the results
  results <- list(
  	sample_names = sample_names,
    dirs = dirs,
  	BSgenomepackagename = BSgenomepackagename,
  	genome_contigs = genome_contigs,
  	exclude_regions = exclude_regions,
    vcf_snp.fix = vcf_snp.fix,
    vcf_indel.fix = vcf_indel.fix,
    vcf_indel.gt = vcf_indel.gt,
    indel_counts.sigfit = indel_counts.sigfit,
    trinuc_bg_counts_ratio = results.trint_counts_and_ratio2genome,
    trinuc_bg_counts.sigfit = results.sample_tri_bg.sigfit,
    trinuc_bg_ratio.sigfit = results.ratio2genome.sigfit,
    genome_trinuc_counts.sigfit = genome_trinuc_counts.sigfit,
    observed_corrected_trinuc_counts = results.trint_subs_obs_corrected,
    observed_trinuc_counts.sigfit = results.trint_subst_obs.sigfit,
    mutation_burden = results.mut_burden,
    purine_trinuc_mismatches = results.SSC_mismatches_purine,
    pyrimidine_trinuc_mismatches = results.SSC_mismatches_pyrimidine,
    estimated_error_rates = results.estimated_error_rates
  )
  
  message("DONE")
  
  return(results)
}
